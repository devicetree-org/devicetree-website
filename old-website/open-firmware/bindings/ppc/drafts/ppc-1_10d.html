<HTML>
<body bgcolor="#ffffff" text="#000000"
link="#0000ff" vlink="#ff0000" alink="ff0000">

<TITLE>
PowerPC Processor Binding
</TITLE>

<center>
<H1>
PowerPC Processor Binding to
<br>
<br>
IEEE 1275-1994<br>
Standard for Boot (Initialization,<br>
Configuration) Firmware<br>
</H1>
<br>

Revision: 1.10 DRAFT
<br>
<br>

April 19,1996
<br>
</center>
<HR><H2>Table of Contents</H2>

<UL>
<A HREF="ppc-1_10d.html#HDR0"><B>1.   Overview</B></A><BR>

<A HREF="ppc-1_10d.html#REF29452"><B>2.   References and Terms</B></A><BR>

<UL>
<A HREF="ppc-1_10d.html#REF26829">2.1.   References</A><BR>

<A HREF="ppc-1_10d.html#HDR1">2.2.   Terms</A><BR>
</UL>

<A HREF="ppc-1_10d.html#HDR2"><B>3.   Data Formats and Representations</B></A><BR>

<A HREF="ppc-1_10d.html#HDR3"><B>4.   Memory Management</B></A><BR>

<UL>
<A HREF="ppc-1_10d.html#HDR4">4.1.   PowerPC address translation model</A><BR>

<UL>
<A HREF="ppc-1_10d.html#HDR5">4.1.1.   Translation requirements</A><BR>

<A HREF="ppc-1_10d.html#REF41703">4.1.2.   Segmented Address Translation</A><BR>

<A HREF="ppc-1_10d.html#HDR6">4.1.3.   Block Address Translation</A><BR>
</UL>

<A HREF="ppc-1_10d.html#HDR7">4.2.   Open Firmware's use of memory</A><BR>

<UL>
<A HREF="ppc-1_10d.html#REF25139">4.2.1.   Real-Mode</A><BR>

<A HREF="ppc-1_10d.html#HDR8">4.2.2.   Virtual-Mode</A><BR>

<A HREF="ppc-1_10d.html#HDR9">4.2.3.    Device Interface (Real-Mode)</A><BR>

<A HREF="ppc-1_10d.html#HDR10">4.2.4.   Device Interface (Virtual-Mode)</A><BR>

<A HREF="ppc-1_10d.html#HDR11">4.2.5.   Client Interface (Real-Mode)</A><BR>

<A HREF="ppc-1_10d.html#REF96317">4.2.6.   Client Interface (Virtual-Mode)</A><BR>

<A HREF="ppc-1_10d.html#HDR12">4.2.7.   User Interface (Real-Mode)</A><BR>

<A HREF="ppc-1_10d.html#HDR13">4.2.8.   User Interface (Virtual-Mode)</A><BR>
</UL>
</UL>

<A HREF="ppc-1_10d.html#HDR14"><B>5.   Properties</B></A><BR>

<UL>
<A HREF="ppc-1_10d.html#HDR15">5.1.   CPU properties</A><BR>

<UL>
<A HREF="ppc-1_10d.html#REF37877">5.1.1.   The Device Tree</A><BR>

<A HREF="ppc-1_10d.html#REF18332">5.1.2.    Physical Address Formats and Representations for CPU Nodes</A><BR>

<UL>
<A HREF="ppc-1_10d.html#HDR16">5.1.2.1.   Numerical Representation</A><BR>

<A HREF="ppc-1_10d.html#HDR17">5.1.2.2.   Text Representation</A><BR>

<A HREF="ppc-1_10d.html#HDR18">5.1.2.3.   Unit Address Representation</A><BR>
</UL>

<A HREF="ppc-1_10d.html#REF25612">5.1.3.   CPUS Node Properties</A><BR>

<A HREF="ppc-1_10d.html#REF89868">5.1.4.    CPU Node Properties</A><BR>

<A HREF="ppc-1_10d.html#HDR19">5.1.5.   TLB properties</A><BR>

<A HREF="ppc-1_10d.html#HDR20">5.1.6.   Internal (L1) cache properties</A><BR>

<A HREF="ppc-1_10d.html#REF34579">5.1.7.   Memory Management Unit properties</A><BR>
</UL>

<A HREF="ppc-1_10d.html#HDR21">5.2.   Ancillary (L2,L3...) cache node properties</A><BR>
</UL>

<A HREF="ppc-1_10d.html#REF77797"><B>6.   Methods</B></A><BR>

<UL>
<A HREF="ppc-1_10d.html#REF77797">6.1.   MMU related methods   </A><BR>
</UL>

<A HREF="ppc-1_10d.html#HDR22"><B>7.   Client Interface Requirements</B></A><BR>

<UL>
<A HREF="ppc-1_10d.html#HDR23">7.1.   Calling Conventions</A><BR>
</UL>

<A HREF="ppc-1_10d.html#HDR24"><B>8.   Client Program Requirements</B></A><BR>

<UL>
<A HREF="ppc-1_10d.html#HDR25">8.1.   Load Address</A><BR>

<A HREF="ppc-1_10d.html#HDR26">8.2.   Initial Program State</A><BR>

<UL>
<A HREF="ppc-1_10d.html#HDR27">8.2.1.   Initial Register Values</A><BR>

<A HREF="ppc-1_10d.html#REF27292">8.2.2.   Initial Stack</A><BR>

<A HREF="ppc-1_10d.html#REF31886">8.2.3.   Client Interface Handler Address</A><BR>

<A HREF="ppc-1_10d.html#REF13831">8.2.4.   Client Program Arguments</A><BR>
</UL>

<A HREF="ppc-1_10d.html#HDR28">8.3.   Caching</A><BR>

<A HREF="ppc-1_10d.html#REF27751">8.4.   Interrupts</A><BR>

<A HREF="ppc-1_10d.html#HDR29">8.5.   Client callbacks</A><BR>

<UL>
<A HREF="ppc-1_10d.html#REF11616">8.5.1.   Real-Mode physical memory management assist callback</A><BR>

<A HREF="ppc-1_10d.html#REF11616">8.5.2.   Virtual address translation assist callbacks</A><BR>
</UL>
</UL>

<A HREF="ppc-1_10d.html#HDR30"><B>9.   User Interface Requirements</B></A><BR>

<UL>
<A HREF="ppc-1_10d.html#HDR31">9.1.   Machine Register Access</A><BR>

<UL>
<A HREF="ppc-1_10d.html#HDR32">9.1.1.   Branch Unit Registers</A><BR>

<A HREF="ppc-1_10d.html#HDR33">9.1.2.   Fixed-Point Registers</A><BR>

<A HREF="ppc-1_10d.html#HDR34">9.1.3.   Floating-Point Registers</A><BR>
</UL>
</UL>

<A HREF="ppc-1_10d.html#HDR35"><B>10.   Configuration Variables</B></A><BR>

<A HREF="ppc-1_10d.html#HDR36"><B>11.   MP Extensions</B></A><BR>

<UL>
<A HREF="ppc-1_10d.html#HDR37">11.1.   The Device Tree</A><BR>

<UL>
<A HREF="ppc-1_10d.html#HDR38">11.1.1.   Additional Properties</A><BR>
</UL>

<A HREF="ppc-1_10d.html#HDR39">11.2.   Initialization</A><BR>

<A HREF="ppc-1_10d.html#HDR40">11.3.   Client Interface Services</A><BR>

<A HREF="ppc-1_10d.html#HDR41">11.4.   Breakpoints</A><BR>

<A HREF="ppc-1_10d.html#HDR42">11.5.   Serialization</A><BR>
</UL>
</UL>

<HR><!-- This file was created with the fm2html filter.The filter is copyright Norwegian Telecom Research and was programmed by Jon Stephenson von Tetzchner.  --><!-- (With modifications by John A. Kingman. 11/95)  --><A NAME="U330140"></A><H2><A NAME="HDR0">1.   Overview</A></H2>
<A NAME="U326745">This document specifies the application of <I>IEEE Std 1275-1994 Standard for Boot (Initialization, Configuration) Firmware, Core Practices and Requirements</I> to computer systems that use the PowerPC Instruction Set Architecture, including instruction-set-specific requirements and practices for debugging, client program interface and data formats. An implementation of Open Firmware for PowerPC <I>shall</I> implement the core requirements as defined in <A HREF="ppc-1_10d.html#REF69242">[1]</A> and the PowerPC-specific extensions described in this binding.</A><p>
<A NAME="U326746">While this document addresses the official PowerPC architecture <A HREF="ppc-1_10d.html#REF44419">[2]</A>, the name "PowerPC" only requires compliance to Book I. The descriptions that follow, and the relevant sections describing translation features for this binding, assume that the system's PowerPC processor(s) implement the entire set of Books I-III. Some "PowerPC" processors may implement different Book II-III features; such processors may need a variant of this binding describing the differences to the mapping functions, etc.</A><p>
<A NAME="U333374"></A><A NAME="U326808"></A><H2><A NAME="REF29452">2.   References and Terms</A></H2>
<A NAME="U332343"></A><A NAME="U326809"></A><H3><A NAME="REF26829">2.1.   References</A></H3>
<A NAME="U326810">This standard shall be used in conjunction with the following publications. When the following standards are superseded by an approved revision, the revision <I>shall</I> apply.</A><p>
<A NAME="U326371"></A><DL COMPACT>
<DT><A NAME="U326811"></A><A NAME="REF69242">[1]  </A><DD><I>IEEE Std 1275-1994 Standard for Boot (Initialization, Configuration) Firmware, Core Practices and Requirements</I>.
<A NAME="U332730"></A><A NAME="U335767"></A><DT><A NAME="U332731"></A><A NAME="REF44419">[2]  </A><DD>  <I>PowerPC Architecture</I>, published by Morgan Kaufmann Publishers, Inc. (ISBN 1-55960-316-6).  Also available from IBM (Customer Reorder Number 52G7487).  Updates to this document are available at <A HREF="http://www.austin.ibm.com/tech/ppc-chg.html">http://www.austin.ibm.com/tech/ppc-chg.html</A>
</DL>
<A NAME="U332354"></A><H3><A NAME="HDR1">2.2.   Terms</A></H3>
<A NAME="U332355">This standard uses technical terms as they are defined in the documents cited in <A HREF="ppc-1_10d.html#REF26829">"References" on page 7</A>, plus the following terms:</A><p>
<A NAME="U326824"><B>core, core specification</B>: refers to <I>IEEE Std 1275-1994 Standard for Boot (Initialization, Configuration) Firmware, Core Practices and Requirements</I></A><p>
<A NAME="U332739"><B>effective address</B>: The 64- or 32-bit address computed by the processor when executing a Storage Access or Branch instruction, or when fetching the next sequential instruction.  If address translation is disabled, the real address is the same as the effective address.  If address translation is enabled, the real address is determined by, but not necessarily identical to, the effective address.</A><p>
<A NAME="U326827"><B>linkage area</B>: An area within the stack that is reserved for saving certain registers across procedure calls in PowerPC run-time models. This area is reserved by the caller and is allocated above the current stack pointer (<B>%r1</B>).</A><p>
<A NAME="U326828"><B>Open Firmware</B>: The firmware architecture defined by the core specification or, when used as an adjective, a software component compliant with the core specification.</A><p>
<A NAME="U326830"><B>procedure descriptor</B>: a data structure used by some PowerPC run-time models to represent a C "pointer to procedure". The first word of this structure contains the actual address of the procedure.</A><p>
<A NAME="U332743"><B>real address</B>: An address that the processor presents on the processor bus.</A><p>
<A NAME="U326831"><B>Real-Mode</B>: The mode in which all addresses passed between the client and Open Firmware are real addresses.</A><p>
<A NAME="U332749"><B>processor bus</B>: The bus that connects the CPU chip to the system.</A><p>
<A NAME="U332750"><B>segmented address translation</B>:  The process whereby an Effective Address (EA) is translated into a Virtual Address (VA<U>)</U> and the virtual address is translated into a Real Address (RA).  (<A HREF="ppc-1_10d.html#REF41703">See "Segmented Address Translation" on page 9.</A> and Section 4.3 of Book III of [2] for more detail.)</A><p>
<A NAME="U326832"><B>Table of Contents (TOC)</B>: A data structure used by some PowerPC run-time models that is used for access to global variables and for inter-module linkage. When a TOC is used, <B>%r2</B> contains its base address.</A><p>
<A NAME="U332757"><B>virtual address</B> (in IEEE 1275 parlance): the address that a program uses to access a memory location or memory-mapped device register.  Depending on the presence or absence of memory mapping hardware in the system, and whether or not that mapping hardware is enabled, a virtual address may or may not be the same as the physical (real) address that appears on an external bus.  The IEEE 1275 definition of "virtual address" corresponds to The PowerPC Architecture's definition of "effective addres."  Except as noted, this document uses the IEEE 1275 definition of virtual address.</A><p>
<A NAME="U332758"><B>Virtual Address </B>(in PowerPC parlance): An internal address within the PowerPC address translation mechanism, used as in intermediate term in the translation of an effective address to the corresponding real address.</A><p>
<A NAME="U326833"><B>Virtual-Mode</B>: The mode in which Open Firmware and its client share a single virtual address space, and address translation is enabled; all addresses passed between the client and Open Firmware are virtual (translated) addresses.</A><p>
<A NAME="U329076"></A><H2><A NAME="HDR2">3.   Data Formats and Representations</A></H2>
<A NAME="U326835">The cell size <I>shall</I> be 32 bits. Number ranges for <I>n</I>, <I>u</I>, and other cell-sized items are consistent with 32-bit, two's-complement number representation.</A><p>
<A NAME="U326836">The required alignment for items accessed with <I>a-addr</I> addresses <I>shall</I> be four-byte aligned (i.e., a multiple of 4).</A><p>
<A NAME="U326837">Each operation involving a <I>qaddr</I> address <I>shall</I> be performed with a single 32-bit access to the addressed location; similarly, each <I>waddr</I> access <I>shall</I> be performed with a single 16-bit access. This implies four-byte alignment for <I>qaddrs</I> and two-byte alignment for <I>waddrs</I>.</A><p>
<A NAME="U332764"></A><H2><A NAME="HDR3">4.   Memory Management</A></H2>
<A NAME="U328956"></A><H3><A NAME="HDR4">4.1.   PowerPC address translation model</A></H3>
<A NAME="U328957">This section describes the model that is used for co-existence of Open Firmware and client programs (i.e., operating systems) with respect to address translation.</A><p>
<A NAME="U328958">The following overview of translation is provided so that the issues relevant to Open Firmware for PowerPC can be discussed. Details that are not relevant to Open Firmware issues (e.g., protection) are not described in detail; the PowerPC architecture <A HREF="ppc-1_10d.html#REF44419">[2]</A>, particularly Book III, should be consulted for the details. For the scope of this section, terms will be used as defined in <A HREF="ppc-1_10d.html#REF44419">[2]</A>.</A><p>
<A NAME="U328965"></A><H4><A NAME="HDR5">4.1.1.   Translation requirements</A></H4>
<A NAME="U328966">The default access mode of storage for load and stores (i.e., with translation disabled -- referred to as <I>Real-Mode</I>) within PowerPC assumes that caches are enabled (in copy-back mode). In order to perform access to I/O device registers, the access mode must be set to Cache-Inhibited, Guarded by establishing a translation with this mode and enabling translation. Thus, even though most of a client program and/or Open Firmware can run with translation disabled, it <U>must</U> be enabled when performing I/O.</A><p>
<A NAME="U332770"></A><A NAME="U332771"></A><H4><A NAME="REF41703">4.1.2.   Segmented Address Translation</A></H4>
<A NAME="U332772">Note:  the use of the term Virtual Address in this section refers to the PowerPC definition, while the rest of the document uses the IEEE 1275 definition of virtual address. (<A HREF="ppc-1_10d.html#REF29452">See "References and Terms" on page 7.</A>)</A><p>
<A NAME="U332776">An Effective Address (EA) of a PowerPC processor is 64{32} bits wide. Each EA is translated into an 80{52}-bit Virtual Address (VA<U>)</U> by prepending a 52{24}-bit Virtual Segment Id (VSID) to the 28 LSbs of the effective address.  On 32-bit implementations, the VSID is obtained by indexing into a set of 16 Segment Registers (SRs) using the 4 MSbs of the EA. On 64-bit implementations, the VSID is looked up in a Segment Table using the 36 MSbs of the EA. Finally, the virtual address is translated into a Real Address (RA).   This is done by mapping the Virtual Page-Number (VPN) (bits 0-67{39} of the VA) into a Real Page Number (RPN) and concatenating this RPN with the byte offset (12 LSbs of the VA). The mapping of VPN to RPN involves a hashing algorithm within a Hashed Page Table (HTAB) to locate a Page Table Entry (PTE) that matches the VPN and using that entry's RPN component. If a valid entry is not found, a Data Storage Interrupt (DSI) or Instruction Storage Interrupt (ISI) is signalled, depending upon the source of the access.</A><p>
<A NAME="U328969">This process is not performed for every translation! Processors will typically have a Translation Look-aside Buffer (TLB) that caches the most recent translations, thus exploiting the natural spatial locality of programs to reduce the overhead of address translation. 64-bit implementations may also implement a Segment Lookaside Buffer (SLB) for the same reasons. On most PowerPC processors, the TLB updates are performed in hardware. However, the architecture allows an implementation to use a software-assisted mechanism to perform the TLB updates. Such schemes must not affect the architected state of the processor unless the translation fails; i.e., the HTAB does not contain a valid PTE for the VA and a DSI/ISI is signalled.</A><p>
<A NAME="U328970">Note:  one unusual feature of this translation mechanism is that valid translations might not be found in the HTAB; the HTAB might be too small to contain all of the currently valid translations. This introduces a level of complexity in the use of address translation by Open Firmware, as discussed below.</A><p>
<A NAME="U328976"></A><H4><A NAME="HDR6">4.1.3.   Block Address Translation</A></H4>
<A NAME="U328977">To further reduce the translation overhead for contiguous regions of virtual and real address spaces (e.g., a frame buffer, or all of real memory), the Block Address Translation (BAT) mechanism is also supported by PowerPC. The Block Address Translation involves the use of BAT entries that contain a Block Effective Page Index (BEPI), a Block Length (BL) specifier and a Block Real Page Number (BRPN); the architecture defines 4 BAT entries for data (DBAT entries) and 4 BAT entries for instruction (IBAT entries)<A HREF="ppc-1_10d.html#FN1">(1)</A>. BAT areas are restricted to a finite set of allowable lengths, all of which are powers of 2.  The smallest BAT area defined is 128 KB (2<em sup>17</em> bytes).  The largest BAT area defined is 256 MB (2<em sup>28</em> bytes).  The starting address of a BAT area in both EA space and RA space must be a multiple of the area's length.</A><p>
<A NAME="U328981">Block Address Translation is done my matching a number of upper bits of the EA (specified by the BL value) against each of the BAT entries. If a match is found, the corresponding BRPN bits replace the matched bits in the EA to produce the RA.</A><p>
<A NAME="U328982">Block Address Translation takes precedence over Segmented Address Translation; i.e., if a mapping for a storage location is present in both a BAT entry and a Page Table Entry or HTAB, the Block Address Translation will be used.</A><p>
<A NAME="U328988"></A><H3><A NAME="HDR7">4.2.   Open Firmware's use of memory</A></H3>
<A NAME="U328989">Open Firmware shall use the memory resources within the space indicated by the real-base, real-size, virt-base and virt-size Configuration Variables defined for PowerPC. As described in the applicable platform binding, a mechanism is defined to enable Open Firmware to determine if its current configuration is consistent with the requirements of the client. </A><p>
<A NAME="U328993">If the client program has specific requirements for physical memory or address space usage, it may establish requirements for Open Firmware's physical and/or virtual address space usage by means of its program header.  When Open Firmware loads the client program, it inspects the program header, and if its current usage of physical memory or virtual address space conflicts with that specified in the program header, Open Firmware shall set the real-base, <B>real-size</B>, virt-base, and <B>virt-size</B> to the configuration variables as specified in the header and restart itself.  Real-base, <B>real-size</B>, virt-base, and <B>virt-size</B> may be specified as -1, in which case the firmware is permitted to choose appropriate values for the variables specified as -1.</A><p>
<A NAME="U328994">If the values of the <B>real-size</B> and/or <B>virt-size</B> configuration variables do not provide sufficient memory and/or virtual address space for the firmware's own use, then the firmware shall not attempt to load a client program and the condition should be reported to the user.  The possibility of not being able to comply with limitations on firmware's size should be tested as the firmware is coming up in order to handle the possibility that a user established an unworkable limitation on the size. Clients can minimize this exposure by setting size to -1 and allowing Open Firmware to choose the size.</A><p>
<A NAME="U328995">A PowerPC Open Firmware binding <I>shall</I> support two different addressing models, depending upon the setting of the <B>real-mode?</B> Configuration Variable. This variable indicates the Open Firmware addressing mode that a client program expects; <B>false</B> (0) indicates Virtual-Mode, <B>true</B> (-1) indicates Real-Mode; the default value of <B>real-mode?</B> is implementation dependent.</A><p>
<A NAME="U328996">The management of <B>real-mode?</B> is analogous to <B>little-endian?</B>. Open Firmware determines its addressing mode using the value of <B>real-mode?</B>. If the current state of <B>real-mode?</B> (and hence, the current state of Open Firmware) is incorrect, it <I>shall</I> set <B>real-mode?</B> appropriately and reset itself, possibly by executing <B>reset-all</B>.</A><p>
<A NAME="U328997">Memory that cannot be allocated for general purpose use, for example physical memory on PowerPC systems used for interrupt vectors and implementation specific areas, shall not appear in the "available" property of the memory node. A Client Program that needs to use such memory for its architected purpose must not claim that area prior to use.</A><p>
<A NAME="U328998">In the following two sections, some of conventions in Real-Mode and Virtual-Mode address translations are described. Remaining sections describe the assumptions that Open Firmware makes about the state and control of the system in regard to Open Firmware's use of system resources for three Open Firmware interfaces (e.g. Device, User and Client interfaces).</A><p>
<A NAME="U329004"></A><A NAME="U329005"></A><H4><A NAME="REF25139">4.2.1.   Real-Mode</A></H4>
<A NAME="U329006">In Real-Mode (when <B>real-mode?</B> is <B>true</B>), the use of address translations by Open Firmware and its client are independent. Either they do not use translation, or their translations are private; they do not share any translations. All interfaces between the two must pass the real address of the data. Any data structure shared by Open Firmware and its client that refers to <I>virt</I> addresses in <A HREF="ppc-1_10d.html#REF69242">[1]</A>, or this binding, must be real addresses.</A><p>
<A NAME="U329010">Note:  in particular, that the address of the Client interface handler, that is passed to the client, has to be a real address.</A><p>
<A NAME="U329011">The Configuration Variables real-base and real-size should indicate the physical memory base and size in which Open Firmware must locate itself.   In Real-Mode, the Configuration Variables virt-base and virt-size do not have meaning and should be set to -1.</A><p>
<A NAME="U329013"></A><H4><A NAME="HDR8">4.2.2.   Virtual-Mode</A></H4>
<A NAME="U329014">When <B>real-mode?</B> is <B>false</B>, Open Firmware <I>shall</I> configure itself to run in <I>Virtual-Mode</I>. In Virtual-Mode, Open Firmware and its client will share a single virtual address space. This binding provides interfaces to allow Open Firmware and its client to ensure that this single virtual address model can be maintained.</A><p>
<A NAME="U329015">The Configuration Variables virt-base and virt-size should indicate the virtual address space base address and size that Open Firmware should use. The Configuration Variables real-base and real-size should indicate the physical memory base and size in which Open Firmware must locate itself. </A><p>
<A NAME="U329016"></A><H4><A NAME="HDR9">4.2.3.    Device Interface (Real-Mode)</A></H4>
<A NAME="U329017">While Open Firmware is performing system initialization and probing functions, it establishes and maintains its own translations. In particular, it maintains its own Page Tables (and/or BAT entries) and handles any DSI/ISI interrupts itself.</A><p>
<A NAME="U329018">Note:  in Real-Mode, all translations will be <I>virt=real</I>; the primary reason for translation is to allow appropriate I/O accesses.</A><p>
<A NAME="U329019"></A><H4><A NAME="HDR10">4.2.4.   Device Interface (Virtual-Mode)</A></H4>
<A NAME="U329020">Open Firmware will establish its own translation environment, handling DSI/ISI interrupts as in the Real-Mode case. However, this environment will, in general, contain translations in which virtual addresses do not equal real addresses. The virtual address space used by Open Firmware must be compatible with its client.</A><p>
<A NAME="U329021">Note:  Since these virtual addresses will be used by the Client and/or User Interfaces (e.g., for pointers to its code, device-tree, etc.), their translations must be preserved until the client OS decides that it no longer requires the services of Open Firmware.</A><p>
<A NAME="U329027"></A><H4><A NAME="HDR11">4.2.5.   Client Interface (Real-Mode)</A></H4>
<A NAME="U329028">In Real-Mode, addresses of client data are real.; the client must ensure that all data areas referred to across the Client Interface are valid real addresses. This may require moving data to meet any requirements for contiguous storage areas (e.g., for <B>read/write</B> calls). Translation <I>shall</I> be disabled before the client interface call is made.</A><p>
<A NAME="U329029">Open Firmware will typically have to maintain its translations in order to perform I/O. Since the client may be running with translation enabled (except for the Client interface call), Open Firmware <I>shall</I> save the state of all relevant translation resources (e.g., SDR1, BATs) and restore them before returning to the client. Likewise, it <I>may</I> take over interrupts for its own use (e.g., for doing "lazy" allocation of BATs); it <I>shall</I> preserve the state of any interrupt vectors for its client.</A><p>
<A NAME="U333802">Since the state of the address translation system is not predictable to any interrupts, the client <I>shall</I> ensure that interrupts are disabled before calling the Client Interface handler and call the handler from only one CPU at a time. The client <I>shall</I> also ensure that other processors do not generate translation exceptions for the duration of the call.</A><p>
<A NAME="U333803">Client programs are not required to assume responsibility for physical memory management. The client program must use the Open Firmware claim client interface service to allocate physical memory while physical memory is managed by Open Firmware.  Physical memory shall remain managed by Open Firmware until the client program defines the real-mode physical memory management assist callbacks.  Physical memory must be managed by the client program once the client program defines the real-mode physical memory management assist callbacks.  Open Firmware shall use the client program's real-mode physical memory management assist callbacks to allocate physical memory after the client program has assumed physical memory management.</A><p>
<A NAME="U329107">In Real-Mode, <B>claim</B> methods <I>shall</I> not allocate more pages than are necessary to satisfy the request.</A><p>
<A NAME="U329249"></A><A NAME="U329032"></A><H4><A NAME="REF96317">4.2.6.   Client Interface (Virtual-Mode)</A></H4>
<A NAME="U329033">Client interface calls are essentially "subroutine" calls to Open Firmware. Hence, the client interface executes in the environment of its client, including any translations that the OS has established. E.g., addresses passed in to the client interface are assumed to be valid virtual addresses within the scope of the OS. Any DSI/ISI interrupts are either invalid addresses or caused by HTAB "spills". In either case, the OS has the responsibility for the handling of such exceptions.</A><p>
<A NAME="U329034">Note:  addresses that the Open Firmware internal use will be those that were established by the Device interface (or, by subsequent actions of the Client or User interface). Thus, the client must preserve these Open Firmware translations if it takes over the virtual memory management function.</A><p>
<A NAME="U329035">In addition to using existing translations, the Client Interface might require the establishment of new translations (e.g., due to <B>map-in</B> calls during <B>open</B> time), or the removal of old translations (e.g., during <B>map-out</B> calls during <B>close</B> time). Since this requires altering the Client's translation resources (e.g., Page Tables), possibly handling spill conditions, Open Firmware can not know how to perform these updates.</A><p>
<A NAME="U329036">Hence, there <I>shall</I> be callback services provided by the client for use by Open Firmware for such actions; see <A HREF="ppc-1_10d.html#REF11616">section 8.5.2.</A></A><p>
<A NAME="U329118">In order to let clients (i.e., target operating systems) know where Open Firmware lives in the address space, the following rules <I>shall</I> be followed by an Open Firmware implementation for PowerPC and by client programs.</A><p>
<A NAME="U329119">Open Firmware:</A><p>

<UL>
<A NAME="U329123"><LI>Open Firmware <I>shall</I> maintain its "translations" "mmu"-node property (see <A HREF="ppc-1_10d.html#REF34579">section 5.1.7.</A>)</A><BR>

<A NAME="U329124"><LI>Open Firmware's <B>claim</B> methods <I>shall </I>not allocate more pages than are necessary to satisfy the request.</A><BR>

<A NAME="U329125"><LI>When a client executes <B>set-callback</B>, Open Firmware <I>shall</I> attempt to invoke the "translate" callback. If the translate callback is implemented, Open Firmware <I>shall</I> cease use of address translation hardware, instead using the client callbacks for changes to address translation. </A><BR>
</UL>


<A NAME="U329126">The <B>exit</B> service must continue to work after a <B>set-callback</B> that takes over address translation. This implies that Open Firmware takes responsibility for address translation hardware upon <B>exit</B> and must maintain internal information about translations that it requests of the client.</A><p>
<A NAME="U329127">Client Programs:</A><p>

<UL>
<A NAME="U329128"><LI>Client programs that take control of the management of address translation hardware and expect to be able to subsequently invoke Open Firmware client services must provide callbacks to assist Open Firmware in address translation (see <A HREF="ppc-1_10d.html#REF11616">section 8.5.2.</A>).</A><BR>

<A NAME="U329132"><LI>A client program shall not directly manipulate any address translation hardware before it either a) ceases to invoke OF client services or b) issues a <B>set-callback </B>to install the "translate" callback.</A><BR>
</UL>


<A NAME="U329133">Note:  The intended sequence is that a client program will first issue a set-callback and then take control of address translation hardware. Address translation hardware includes BAT entries, page table, segment registers, Machine State Register and the interrupt vectors relating to translation faults.</A><p>
<A NAME="U329040"></A><H4><A NAME="HDR12">4.2.7.   User Interface (Real-Mode)</A></H4>
<A NAME="U329041">In Real-Mode, Open Firmware regains total control of the system. As with the Client interface in Real-Mode, it should save the state of the translation resources (including interrupt vectors) upon entry and should restore them upon exit.</A><p>
<A NAME="U329047"></A><H4><A NAME="HDR13">4.2.8.   User Interface (Virtual-Mode)</A></H4>
<A NAME="U329048">When the User interface is invoked, Open Firmware is responsible for managing the machine. Therefore, it will take over control of any relevant interrupt vectors for its own handling. In particular, it will take over DSI/ISI handling in order to report errors to the user for bad addresses, protection violations, etc. However, as described above, one source of DSI/ISI may simply be HTAB spills. As with the case of map-in and map-out calls, the User interface can not know how to handle such spill conditions, itself, or even if this is, in fact, a spill versus a bad address.</A><p>
<A NAME="U329049">Hence, this binding defines callback services that the client provides for use by Open Firmware; see <A HREF="ppc-1_10d.html#REF11616">section 8.5.2.</A>.</A><p>
<A NAME="U328951"></A><H2><A NAME="HDR14">5.   Properties</A></H2>
<A NAME="U326922">This section describes the standard properties of a PowerPC Open Firmware implementation.</A><p>
<A NAME="U326930"></A><H3><A NAME="HDR15">5.1.   CPU properties</A></H3>
<A NAME="U330798"></A><A NAME="U330783"></A><H4><A NAME="REF37877">5.1.1.   The Device Tree</A></H4>
<A NAME="U332649">Open Firmware requires that the multiple instances of any device that appears more than once in the device tree must be distinguishable by means of their "reg" properties. The "reg" property must express the "address" of each node relative to its parent "bus". Furthermore, the core specification says that the root node of the device tree usually represents the "main physical bus" of the system. Thus, if processors are not directly addressable on the main physical bus, as is expected to be the case on many/most PowerPC-based systems, the CPU nodes on such systems may not be children of the root node but must instead be children of a pseudo-device node. In this case, the name of the pseudo-device node, which will usually be a child of the root node, shall be "cpus".</A><p>
<A NAME="U332906">The "cpus" node shall have one child node of device_type "cpu" for each processor.</A><p>
<A NAME="U332907"></A><A NAME="U332908"></A><H4><A NAME="REF18332">5.1.2.    Physical Address Formats and Representations for CPU Nodes</A></H4>
<A NAME="U332909"></A><H5><A NAME="HDR16">5.1.2.1.   Numerical Representation</A></H5>
<A NAME="U335610">The numerical representation of a processor's "address" in a PowerPC system shall consist of one cell, encoded as follows (Bit# 0 refers to the least significant bit):</A><p>
<pre>
======================================================
<A NAME="U335613">Bit#</A>          |<A NAME="U335615">33222222</A> |<A NAME="U335649">22221111</A> |<A NAME="U335651">11111100</A> |<A NAME="U335712">00000000</A> 
              |<A NAME="U335743">10987654</A> |<A NAME="U335744">32109876</A> |<A NAME="U335745">54321098</A> |<A NAME="U335746">76543210</A> 
==============|=========|=========|=========|=========
              |         |         |         |         
<A NAME="U335759">phys.lo cell:</A> |<A NAME="U335760">00000000</A> |<A NAME="U335761">00000000</A> |<A NAME="U335762">00000000</A> |<A NAME="U335763">pppppppp</A> 
======================================================
</pre>
<A NAME="U335629">  where: <I>pppppppp</I> is an 8-bit integer representing the interprocessor interrupt identifier used by the platform.</A><p>
<A NAME="U332667"></A><H5><A NAME="HDR17">5.1.2.2.   Text Representation</A></H5>
<A NAME="U332668">The text representation of a processor's "address" shall be an ASCII hexadecimal number in the range 0...FF. </A><p>
<A NAME="U332669">Conversion of the hexadecimal number from text representation to numeric representation shall be case insensitive, and leading zeros shall be permitted but not required.</A><p>
<A NAME="U332670">Conversion from numeric representation to text representation shall use the lower case forms of the hexadecimal digits in the range a..f, suppressing leading zeros.</A><p>
<A NAME="U332671"></A><H5><A NAME="HDR18">5.1.2.3.   Unit Address Representation</A></H5>
<A NAME="U332672">A processor's "unit-number" (i.e. the first component of its "reg" value) is the interprocessor interrupt destination identifier used by the platform. For a uni-processor platform, the "unit-number" shall be zero. </A><p>
<A NAME="U332673"></A><A NAME="U332674"></A><H4><A NAME="REF25612">5.1.3.   CPUS Node Properties</A></H4>
<A NAME="U332651">The following properties shall be created within the "cpus" node.</A><p>
<H4><A NAME="U332622">"#address-cells"</A></H4>
<A NAME="U332623">Standard <I>prop-name</I> to define the number of cells required to represent the physical addresses for the "cpu" nodes (i.e., the children of the "cpus" node).</A><p>
<A NAME="U332918"><I>prop-encoded-array</I>: Integer constant 1, encoded as with encode-int.</A><p>
<A NAME="U332919">The value of "#address-cells" for the "cpus" node <I>shall</I> be 1.</A><p>
<H4><A NAME="U332920">"#size-cells"</A></H4>
<A NAME="U329481">Standard <I>prop-name </I>to define the number of cells necessary to represent the length of a physical address range.</A><p>
<A NAME="U329484"><I>prop-encoded-array</I>: Integer constant 0, encoded as with <B>encode-int.</B></A><p>
<A NAME="U329488">The value of "#size-cells" for the "cpus" pseudo-device node is 0 because the processors that are represented by the cpu nodes do not consume any physical address space.</A><p>
<A NAME="U332129"></A><A NAME="U329489"></A><H4><A NAME="REF89868">5.1.4.    CPU Node Properties</A></H4>
<A NAME="U326931">For each CPU in the system, a cpu-node <I>shall</I> be defined as a child of "cpus." The following properties apply to each of these nodes. The "cpus" node shall not have "reg" or "ranges" properties. </A><p>
<H4><A NAME="U328152">"name"</A></H4>
<A NAME="U328153">Open Firmware standard property. The value of the is property shall be of the form: "PowerPC,&lt;name&gt;", where &lt;name&gt; is the name of the processor chip which may be displayed to the user.  </A><p>
<H4><A NAME="U326932">"device_type" </A></H4>
<A NAME="U326933">Open Firmware standard property. The value of this property for CPU nodes <I>shall</I> be "cpu".</A><p>
<H4><A NAME="U326934">"reg"</A></H4>
<A NAME="U329491">Standard <I>prop-name </I>to define a cpu node's unit-address. </A><p>
<A NAME="U329529"><I>prop-encoded-array</I>: an integer encoded as with <B>encode-int</B>. </A><p>
<A NAME="U332680">For a cpu node, the first and only value of the "reg" property shall be the number of the per-processor interrupt line assigned to the processor represented by the node. For a uni-processor platform, the value of the "reg" property shall be zero.</A><p>
<H4><A NAME="U329490">"cpu-version"</A></H4>
<A NAME="U326935">Standard property, encoded as with <B>encode-int</B>, that represents the processor type. This shall be the value obtained by reading the Processor Version Register of the CPU.</A><p>
<H4><A NAME="U326936">"clock-frequency"</A></H4>
<A NAME="U326937">Standard property, encoded as with <B>encode-int</B>, that represents the internal processor speed (in hertz) of this node.</A><p>
<H4><A NAME="U326938">"timebase-frequency"</A></H4>
<A NAME="U326939">Standard property, encoded as with <B>encode-int</B>, that represents the rate (in hertz) at which the PowerPC TimeBase and Decrementer registers are updated.</A><p>
<A NAME="U328558">Note: The 601 PowerPC does not have a timebase frequency, therefore on a 601 PowerPC the value reported in this property shall be 1 billion (1 x 10<em sup>9</em>) which represents the logical rate of the real time clock.</A><p>
<H4><A NAME="U328923">"64-bit"</A></H4>
<A NAME="U328924">prop-encoded-array: &lt;none&gt;</A><p>
<A NAME="U328926">This property, if present, indicates that the PowerPC microprocessor defined by this CPU node is a 64-bit implementation of the PowerPC architecture. The absence of this property indicates that the microprocessor defined by this CPU node is a 32 bit implementation of the PowerPC architecture</A><p>
<H4><A NAME="U328934">"603-translation"</A></H4>
<A NAME="U328935"><I>prop-encoded-array</I>: &lt;none&gt;</A><p>
<A NAME="U328936">This property, if present, indicates that the PowerPC microprocessor defined by this CPU node uses the PowerPC 603 defined mechanism to update its Translation Lookaside Buffers (TLBs). The absence of this property indicates that the PowerPC microprocessor defined by this CPU node does not use the PowerPC 603 defined mechanism to update its TLBs.</A><p>
<H4><A NAME="U328937">"603-power-management"</A></H4>
<A NAME="U329252"><I>prop-encoded-array</I>: &lt;none&gt; </A><p>
<A NAME="U328938">This property, if present, indicates that the PowerPC microprocessor defined by this CPU node implements the PowerPC 603 defined power management states. The absence of this property indicates that the PowerPC microprocessor defined by this CPU node does not support the PowerPC 603 defined power management states.</A><p>
<H4><A NAME="U332953">"bus-frequency"</A></H4>
<A NAME="U332954">Standard property, encoded as with <B>encode-int</B>, that represents the speed (in hertz) of this processor's bus.</A><p>
<H4><A NAME="U332955">"32-64-bridge"</A></H4>
<A NAME="U332956"><I>prop-encoded-array</I>: &lt;none&gt; </A><p>
<A NAME="U332957">This property, if present, indicates that the PowerPC microprocessor defined by this CPU node implements the "Bridge Facilities and Instructions for 64-bit Implementations" as described in an appendix of Book III of [2]. The absence of this property indicates that the PowerPC microprocessor defined by this CPU node does not support these facilities and instructions.</A><p>
<H4><A NAME="U332958">"emulation-assist-unit"</A></H4>
<A NAME="U332959"><I>prop-encoded-array</I>: &lt;none&gt; </A><p>
<A NAME="U332960">This property, if present, indicates that the PowerPC microprocessor defined by this CPU node implements the emulation assist unit (EAU). The absence of this property indicates that the PowerPC microprocessor defined by this CPU node does not implement the EAU.</A><p>
<H4><A NAME="U332961">"external-control"</A></H4>
<A NAME="U332962"><I>prop-encoded-array</I>: &lt;none&gt; </A><p>
<A NAME="U332963">This property, if present, indicates that the PowerPC microprocessor defined by this CPU node implements the External Control Facility as described in the "Optional Facilities and Instructions" appendix of Book II of [2].  The absence of his property indicates that the PowerPC microprocessor defined by this CPU node does not support the External Control Facility.</A><p>
<H4><A NAME="U332964">"general-purpose"</A></H4>
<A NAME="U332965"><I>prop-encoded-array</I>: &lt;none&gt; </A><p>
<A NAME="U332966">This property, if present, indicates that the PowerPC microprocessor defined by this CPU node implements the floating point instructions <B>fsqrt</B> and <B>fsqrts</B>.  The absence of this property indicates that the PowerPC microprocessor defined by this CPU node does not support the floating point instructions <B>fsqrt</B> and <B>fsqrts</B>.</A><p>
<H4><A NAME="U332967">"reservation-granule-size"</A></H4>
<A NAME="U332968">Standard property, encoded as with <B>encode-int</B>, that represents the reservation granule size (i.e., the minimum size of lock variables) supported by this processor, in bytes.</A><p>
<H4><A NAME="U332969">"graphics"</A></H4>
<A NAME="U332970"><I>prop-encoded-array</I>: &lt;none&gt; </A><p>
<A NAME="U332971">This property, if present, indicates that the PowerPC microprocessor defined by this CPU node implements the floating point instructions <B>stfiwx, fres, frsqrte, </B>and<B> fsel</B>. The absence of this property indicates that the PowerPC microprocessor defined by this CPU node does not support the floating point instructions <B>stfiwx, fres, frsqrte, </B>and<B> fsel</B>.</A><p>
<H4><A NAME="U332972">"performance-monitor"</A></H4>
<A NAME="U332973"><I>prop-encoded-array</I>: &lt;none&gt; </A><p>
<A NAME="U332974">This property, if present, indicates that the PowerPC microprocessor defined by this CPU node implements the performance monitor functionality.  The absence of this property indicates that the PowerPC microprocessor defined by this CPU node does not support this performance monitor functionality.</A><p>
<H4><A NAME="U332975">"tlbia"</A></H4>
<A NAME="U332976"><I>prop-encoded-array</I>: &lt;none&gt; </A><p>
<A NAME="U332977">This property, if present, indicates that the PowerPC microprocessor defined by this CPU node implements the <B>tlbia</B> instruction.  The absence of this property indicates that the PowerPC microprocessor defined by this CPU node does not support the <B>tlbia</B> instruction.</A><p>
<A NAME="U328927"></A><H4><A NAME="HDR19">5.1.5.   TLB properties</A></H4>
<A NAME="U328928">Since the PowerPC architecture defines the MMU as being part of the processor, the properties defined by Section 3.6.5 of <A HREF="ppc-1_10d.html#REF69242">[1]</A> and the following MMU-related properties shall be presented under "cpu" nodes.</A><p>
<H4><A NAME="U327316">"tlb-size"</A></H4>
<A NAME="U327255">Standard property, encoded as with <B>encode-int</B>, that represents the total number of TLB entries.</A><p>
<H4><A NAME="U327256">"tlb-sets"</A></H4>
<A NAME="U327257">Standard property, encoded as with encode-int, that represents the number of associativity sets of the TLB. A value of 1 indicates that the TLB is fully-associative.</A><p>
<H4><A NAME="U333847">"tlb-split"</A></H4>
<A NAME="U333848">This property, if present, shall indicate that the TLB has a split organization. The absence of this property shall indicate that the TLB has a unified organization.</A><p>
<H4><A NAME="U333864">"d-tlb-size"</A></H4>
<A NAME="U333867">Standard property, encoded as with encode-int, that represents the total number of d-TLB entries.</A><p>
<H4><A NAME="U333870">"d-tlb-sets"</A></H4>
<A NAME="U333872">Standard property, encoded as with encode-int, that represents the number of associativity sets of the d-TLB. A value of 1 indicates that the d-TLB is fully-associative.</A><p>
<H4><A NAME="U333876">"i-tlb-size"</A></H4>
<A NAME="U333878">Standard property, encoded as with encode-int, that represents the total number of i-TLB entries.</A><p>
<H4><A NAME="U333881">"i-tlb-sets"</A></H4>
<A NAME="U333883">Standard property, encoded as with encode-int, that represents the number of associativity sets of the i-TLB. A value of 1 indicates that the i-TLB is fully-associative.</A><p>
<A NAME="U326940"></A><H4><A NAME="HDR20">5.1.6.   Internal (L1) cache properties</A></H4>
<A NAME="U326941">The PowerPC architecture defines a Harvard-style cache architecture; however, unified caches are an implementation option. All of the PowerPC cache instructions act upon a cache "block" (also referred to as a cache "line"). The internal (also referred to as "L1") caches of PowerPC processors are represented in the Open Firmware device tree by the following properties contained under "cpu" nodes.</A><p>
<H4><A NAME="U326942">"cache-unified"</A></H4>
<A NAME="U326943">This property, if present, indicates that the internal cache has a unified organization. Absence of this property indicates that the internal caches are implemented as separate instruction and data caches.</A><p>
<H4><A NAME="U326944">"i-cache-size"</A></H4>
<A NAME="U326945">Standard property, encoded as with <B>encode-int</B>, that represents the total size (in bytes) of the internal instruction cache.</A><p>
<H4><A NAME="U326946">"i-cache-sets"</A></H4>
<A NAME="U326947">Standard property, encoded as with <B>encode-int</B>, that represents number of associativity sets of the internal instruction cache. A value of 1 signifies that the instruction cache is fully associative.</A><p>
<H4><A NAME="U326948">"i-cache-block-size"</A></H4>
<A NAME="U326949">Standard property, encoded as with <B>encode-int</B>, that represents the internal instruction cache's block size, in bytes.</A><p>
<H4><A NAME="U326950">"d-cache-size"</A></H4>
<A NAME="U326951">Standard property, encoded as with <B>encode-int</B>, that represents the total size (in bytes) of the internal data cache.</A><p>
<H4><A NAME="U326952">"d-cache-sets"</A></H4>
<A NAME="U326953">Standard property, encoded as with <B>encode-int</B>, that represents number of associativity sets of the internal data cache. A value of 1 signifies that the data cache is fully associative.</A><p>
<H4><A NAME="U326954">"d-cache-block-size"</A></H4>
<A NAME="U326955">Standard property, encoded as with <B>encode-int</B>, that represents the internal (L1) data cache's block size, in bytes.</A><p>
<H4><A NAME="U326956">"l2-cache"</A></H4>
<A NAME="U326957">Standard property, encoded as with <B>encode-int</B>, that represents the next level of cache in the memory hierarchy.</A><p>
<A NAME="U326958">Absence of this property indicates that no further levels of cache are present. If present, its value is the <I>phandle</I> of the device node that represents the next level of cache.</A><p>
<H4><A NAME="U333924">"i-cache-line-size"</A></H4>
<A NAME="U333927">Standard property, encoded as with encode-int, that represents the internal instruction cache's line size, in bytes, if different than its block size.</A><p>
<H4><A NAME="U333931">"d-cache-line-size"</A></H4>
<A NAME="U333933">Standard property, encoded as with encode-int, that represents the internal data cache's line size, in bytes, if different than its block size.</A><p>
<A NAME="U333937">Note:  If this is a unified cache, the corresponding i- and d- sizes must be equal.</A><p>
<A NAME="U328295"></A><A NAME="U328178"></A><H4><A NAME="REF34579">5.1.7.   Memory Management Unit properties</A></H4>
<A NAME="U328179">To aid a client in "taking over" the translation mechanism and still interact with Open Firmware (via the clie<I>nt interface</I>), the client needs to know what translations have been established by Open Firmware. The following standard property shall exist within the package to which the "mmu" property of the /chosen package refers.</A><p>
<H4><A NAME="U328180">"translations"</A></H4>
<A NAME="U328181">This property, consisting of sets of translations, defines the currently active translations that have been established by Open Firmware (e.g., using map). Each set has the following format:</A><p>
<A NAME="U328182">    (virt size phys mode )</A><p>
<A NAME="U328183">Each value is encoded as with <B>encode-int</B>.</A><p>
<A NAME="U328174"></A><H3><A NAME="HDR21">5.2.   Ancillary (L2,L3...) cache node properties</A></H3>
<A NAME="U326960">Some systems might include secondary (L2) or tertiary (L3), etc. cache(s). As with the L1 caches, they can be implemented as either Harvard-style or unified. Unlike the L1 properties, that are contained within the "cpu" nodes, the properties of ancillary caches are contained within other device tree nodes.</A><p>
<A NAME="U326961">The following properties define the characteristics of such ancillary caches. These properties <I>shall</I> be contained as a child node of one of the CPU nodes; this is to allow path-name access to the node. All "cpu" nodes that share the same ancillary cache (including the cpu node under which the ancillary cache node is contained) <I>shall</I> contain an "l2-cache" property whose value is the <I>phandle</I> of that ancillary cache node.</A><p>
<A NAME="U326962">Note:  The "l2-cache" property shall be used in one level of the cache hierarchy to represent the next level. The device node for a subsequent level shall appear as a child of one of the caches in the hierarchy to allow path-name traversal.</A><p>
<H4><A NAME="U326963">"device_type"</A></H4>
<A NAME="U326964">Open Firmware Standard property; the device_type of ancillary cache nodes <I>shall</I> be "cache".</A><p>
<H4><A NAME="U326965">"cache-unified"</A></H4>
<A NAME="U326966">This property, if present, indicates that the cache at this node has a unified organization. Absence of this property indicates that the caches at this node are implemented as separate instruction and data caches.</A><p>
<H4><A NAME="U326967">"i-cache-size"</A></H4>
<A NAME="U326968">Standard property, encoded as with <B>encode-int</B>, that represents the total size (in bytes) of the instruction cache at this node.</A><p>
<H4><A NAME="U326969">"i-cache-sets"</A></H4>
<A NAME="U326970">Standard property, encoded as with <B>encode-int</B>, that represents number of associativity sets of the instruction cache at this node. A value of 1 signifies that the instruction cache is fully associative.</A><p>
<H4><A NAME="U326971">"d-cache-size"</A></H4>
<A NAME="U326972">Standard property, encoded as with <B>encode-int</B>, that represents the total size (in bytes) of the data cache at this node.</A><p>
<H4><A NAME="U326973">"d-cache-sets"</A></H4>
<A NAME="U326974">Standard property, encoded as with <B>encode-int</B>, that represents number of associativity sets of the instruction cache at this node. A value of 1 signifies that the instruction cache is fully associative.</A><p>
<H4><A NAME="U326975">"l2-cache"</A></H4>
<A NAME="U326976">Standard property, encoded as with <B>encode-int</B>, that represents the next level of cache in the memory hierarchy.</A><p>
<A NAME="U326977">Absence of this property indicates that no further levels of cache are present. If present, its value is the <I>phandle</I> of the device node that represents the cache at the next level.</A><p>
<H4><A NAME="U334888">"i-cache-line-size"</A></H4>
<A NAME="U334889">Standard property, encoded as with encode-int, that represents the internal instruction cache's line size, in bytes, if different than its block size.</A><p>
<H4><A NAME="U334890">"d-cache-line-size"</A></H4>
<A NAME="U334891">Standard property, encoded as with encode-int, that represents the internal data cache's line size, in bytes, if different than its block size.</A><p>
<A NAME="U334892">Note:  If this is a unified cache, the corresponding i- and d- sizes must be equal.</A><p>
<A NAME="U326354"></A><A NAME="U326984"></A><H2><A NAME="REF77797">6.   Methods</A></H2>
<A NAME="U328194">This section describes the additional standard methods required of a PowerPC Open Firmware implementation.</A><p>
<A NAME="U326365"></A><A NAME="U327318"></A><H3><A NAME="REF77797">6.1.   MMU related methods   </A></H3>
<A NAME="U326985">The MMU methods defined by section 3.6.5. of <A HREF="ppc-1_10d.html#REF69242">[1]</A> <I>shall</I> be implemented by CPU nodes. The value of the <I>mode</I> parameter for the relevant methods (e.g., <B>map</B>) <I>shall</I> be the value that is contained within PTEs that control Write-through, Cache-Inhibit, Memory-coherent, Guarded and the 2 protection bits; thus, its format is: <B>WIMGxPP</B>, where x is a reserved bit that <I>shall</I> be 0. In order for I/O accesses to be properly performed in a PowerPC system, address ranges that are mapped by map-in <I>shall</I> be marked as Cache-Inhibited, Guarded.</A><p>
<A NAME="U332704">The default mode (i.e., the mode specified when the value of the <I>mode</I> argument is -1) for the map-in and modify MMU methods of CPU nodes is defined as follows:</A><p>
<A NAME="U332705">If the beginning of the physical address range affected by the operation refers to system memory, the values for <B>WIMGxPP</B> <I>shall</I> be  W=0, I=0, M=0, G=1, PP=10.</A><p>
<A NAME="U332712">If the beginning of the physical address range affected by the operation refers to an I/O address, the values for WIMGxPP <I>shal</I>l be W=1, I=1, M=0, G=1, PP=10.</A><p>
<A NAME="U326986"></A><H2><A NAME="HDR22">7.   Client Interface Requirements</A></H2>
<A NAME="U326987">A PowerPC Open Firmware implementation <I>shall</I> implement a client interface (as defined in chapter 6 of <A HREF="ppc-1_10d.html#REF69242">[1]</A>) according to the specifications contained within this section.</A><p>
<A NAME="U326988"></A><H3><A NAME="HDR23">7.1.   Calling Conventions</A></H3>
<A NAME="U334330">To invoke a client interface service, a <I>client program </I>constructs a client interface <I>argument array</I> as specified in the core Open Firmware document, places its address in <B>r</B><B>3</B> and transfers to the <I>client interface handler</I>, with the return address in <B>l</B><B>r</B>. (A typical way of accomplishing this is to copy the <I>client interface handler</I>'s address into <B>c</B><B>tr</B> and executing a <B>bctrl</B>.)</A><p>
<A NAME="U334470">The term "preserved" below shall mean that the register has the same value when returning as it did when the call was made.</A><p>
<pre>
<A NAME="U334446">Table 1. Register usage conventions</A> 
=======================================================================================
<A NAME="U334340">Register(s)</A> |<A NAME="U334342">      Value -- real-mode</A>        |<A NAME="U334344">Value -- virt-mode</A>                |<A NAME="U334346">Notes</A> 
============|================================|==================================|======
<A NAME="U334348">msr</A>         |<A NAME="U334350">client interface shall preserve</A> |<A NAME="U334476">client interface shall not modify</A> |      
------------|--------------------------------|----------------------------------|------
<A NAME="U334356">cr</A>          |<A NAME="U334358">client interface shall preserve</A> |<A NAME="U334360">same as real-mode</A>                 |<A NAME="U334362">   1</A>  
------------|--------------------------------|----------------------------------|------
<A NAME="U334364">r1-r2</A>       |<A NAME="U334366">client interface shall preserve</A> |<A NAME="U334368">same as real-mode</A>                 |      
------------|--------------------------------|----------------------------------|------
<A NAME="U334372">r3</A>          |<A NAME="U334374">argument array address on cli-</A>  |<A NAME="U334376">same as real-mode</A>                 |<A NAME="U334378">   2</A>  
            |ent interface entry             |                                  |      
------------|--------------------------------|----------------------------------|------
            |<A NAME="U334382">result value (true or false) </A>   |<A NAME="U334384">same as real-mode</A>                 |<A NAME="U334386">   2</A>  
            |on client interface return      |                                  |      
------------|--------------------------------|----------------------------------|------
<A NAME="U334388">r13-r31</A>     |<A NAME="U334390">client interface shall preserve</A> |<A NAME="U334392">same as real-mode</A>                 |      
------------|--------------------------------|----------------------------------|------
<A NAME="U334396">sprg0-</A>      |<A NAME="U334398">client interface shall preserve</A> |<A NAME="U334484">client interface shall not modify</A> |      
sprg3       |                                |                                  |      
------------|--------------------------------|----------------------------------|------
<A NAME="U334404">fpscr</A>       |<A NAME="U334406">client interface shall preserve</A> |<A NAME="U334408">same as real-mode</A>                 |      
------------|--------------------------------|----------------------------------|------
<A NAME="U334412">f0-f31</A>      |<A NAME="U334414">client interface shall preserve</A> |<A NAME="U334416">same as real-mode</A>                 |      
------------|--------------------------------|----------------------------------|------
<A NAME="U334420">lr,</A>         |<A NAME="U334424">undefined</A>                       |<A NAME="U334426">same as real-mode</A>                 |<A NAME="U334428">   <B></B></A>   
<A NAME="U334421">ctr,</A>        |                                |                                  |      
<A NAME="U334422">xer</A>         |                                |                                  |      
------------|--------------------------------|----------------------------------|------
<A NAME="U334430">sr0-sr15</A>    |<A NAME="U334432">client interface shall preserve</A> |<A NAME="U334490">client interface shall not modify</A> |      
------------|--------------------------------|----------------------------------|------
<A NAME="U334438">Other SPRs</A>  |<A NAME="U334440">client interface shall preserve</A> |<A NAME="U334442">same as real-mode</A>                 |<A NAME="U334444">   3</A>  
            |                                |                                  |      
=======================================================================================
</pre>
<A NAME="U334459">Notes</A><p>
<A NAME="U334460"><B>1. </B>Only the non-volatile fields (cr2-cr4) need to be preserved.</A><p>
<A NAME="U334464"><B>2. </B>As defined by section 6.3.1. of <A HREF="ppc-1_10d.html#REF69242">[1]</A>.</A><p>
<A NAME="U334465"><B>3.</B> Other special purpose registers</A><p>
<A NAME="U334331">The <I>client interface handler</I> <I>shall</I> perform the service specified by the contents of the argument array that begins at the address in <B>r</B><B>3</B>, place the return value (indicating success or failure of the attempt to invoke the client interface service) back into <B>r</B><B>3</B>, and return to the <I>client program</I>. This is typically done by a Branch to Link Register (<B>blr</B>).</A><p>
<A NAME="U326995">The <I>client interface handler</I> <I>shall</I> preserve the contents of the Stack Pointer (<B>r</B><B>1</B>), TOC Pointer (<B>r</B><B>2</B>), Condition Register (<B>c</B><B>r</B>) all non-volatile registers (<B>r</B><B>13</B>-<B>r</B><B>31</B>) and all special purpose registers except <B>l</B><B>r</B>, <B>c</B><B>tr</B><B> </B>and <B>x</B><B>er</B>.</A><p>
<A NAME="U326996">The preservation of r2 allows TOC-based client programs to function correctly. Open Firmware <I>shall not</I> depend upon whether its client is TOC-based or not. If the client interface handler, itself, is TOC-based, it must provide for the appropriate initialization of its <B>r2</B>.</A><p>
<A NAME="U326997"></A><H2><A NAME="HDR24">8.   Client Program Requirements</A></H2>
<A NAME="U327025"></A><H3><A NAME="HDR25">8.1.   Load Address</A></H3>
<A NAME="U334555">The client's load address is specified by the value of the <B>load-base</B> Configuration Variable. The value of <B>load-base</B> defines the default load address for <I>client program</I>s when using the <B>load</B> method.  <B>Load-base </B>shall be a real address in real mode or a virtual address in virtual mode. Note that this address represents the area into which the client program file will be read by <B>load</B>; it does not correspond to the addresses at which the program will be executed. All of physical memory from <B>load-base</B> to either the start of Open Firmware physical memory or the end of physical memory, whichever comes first, shall be available for loading the client program.</A><p>
<A NAME="U327027"></A><H3><A NAME="HDR26">8.2.   Initial Program State</A></H3>
<A NAME="U327028">This section defines the "initial program state", the execution environment that exists when the first machine instruction of a <I>client program</I> of the format specified above begins execution. Many aspects of the "initial program state" are established by <B>init-program</B>, which sets the <I>saved program state</I> so that subsequent execution of <B>go</B> will begin execution of the <I>client program</I> with the specified environment.</A><p>
<A NAME="U327029"></A><H4><A NAME="HDR27">8.2.1.   Initial Register Values</A></H4>
<A NAME="U327030">Upon entry to the client program, the following registers shall contain the following values:</A><p>
<pre>
<A NAME="U326547">Table 2. Initial Register Values</A> 
==================================================================
<A NAME="U326496">Register(s)</A> |<A NAME="U326493">         Value</A>                                |<A NAME="U326494">Notes</A> 
============|==============================================|======
<A NAME="U326499">msr</A>         |<A NAME="U326495">EE=0, interrupts disabled</A>                     |<A NAME="U326497"> 1</A>    
------------|----------------------------------------------|------
            |<A NAME="U326498">PR=0, supervisor state</A>                        |      
------------|----------------------------------------------|------
            |<A NAME="U326501">FP=1, floating point enabled</A>                  |      
------------|----------------------------------------------|------
            |<A NAME="U326504">ME=1, machine checks enabled</A>                  |      
------------|----------------------------------------------|------
            |<A NAME="U326507">FE0,FE1=0, floating point exceptions disabled</A> |      
------------|----------------------------------------------|------
            |<A NAME="U326510">IP, see <A HREF="ppc-1_10d.html#REF27751">section 8.4.</A> </A>                         |      
------------|----------------------------------------------|------
            |<A NAME="U326513">IR,DR, see <A HREF="ppc-1_10d.html#REF25139">section 4.2.1.</A></A>                     |      
------------|----------------------------------------------|------
            |<A NAME="U326516">SF=0, 32-bit mode</A>                             |      
------------|----------------------------------------------|------
            |<A NAME="U326519">ILE,LE, little endian support</A>                 |<A NAME="U326521"> 2</A>    
------------|----------------------------------------------|------
<A NAME="U326526">r1</A>          |<A NAME="U326522">see <A HREF="ppc-1_10d.html#REF27292">section 8.2.2.</A></A>                            |      
------------|----------------------------------------------|------
<A NAME="U326529">r2</A>          |<A NAME="U326525">0</A>                                             |<A NAME="U326527"> 3</A>    
------------|----------------------------------------------|------
<A NAME="U326532">r3</A>          |<A NAME="U326528">reserved for platform binding</A>                 |<A NAME="U326530"> 4</A>    
------------|----------------------------------------------|------
<A NAME="U326535">r4</A>          |<A NAME="U326531">reserved for platform binding</A>                 |<A NAME="U326533"> 4</A>    
------------|----------------------------------------------|------
<A NAME="U326538">r5</A>          |<A NAME="U326534">see <A HREF="ppc-1_10d.html#REF31886">section 8.2.3.</A></A>                            |      
------------|----------------------------------------------|------
<A NAME="U326541">r6,r7</A>       |<A NAME="U326537">see <A HREF="ppc-1_10d.html#REF13831">section 8.2.4.</A></A>                            |<A NAME="U326539">   </A>   
------------|----------------------------------------------|------
<A NAME="U326544">Other </A>      |<A NAME="U326540">0</A>                                             |      
user mode   |                                              |      
registers   |                                              |      
==================================================================
</pre>
<A NAME="U327031">Notes:</A><p>
<A NAME="U327032"><B>1</B>. Open Firmware will typically require the use of external interrupts for its <I>user interface</I>. However, when a <I>client program</I> is invoked, external interrupts <I>shall</I> be disabled. If a <I>client program</I> causes the invocation of the user interface, external interrupts <I>may</I> be re-enabled.</A><p>
<A NAME="U326923"><B>2</B>. The 601 processor uses a different mechanism for controlling the endian-mode of the processor. On the 601, the LE bit is contained in the HID0 register; this bit controls the endian-mode of both program and privileged states.</A><p>
<A NAME="U327034"><B>3</B>. Open Firmware does not make any assumptions about whether a client program is TOC-based or not. It is the responsibility of the client program to set <B>r</B><B>2</B> to its TOC, if necessary.</A><p>
<A NAME="U327035"><B>4</B>. As defined in the relevant section of the platform binding.</A><p>
<A NAME="U326317"></A><A NAME="U327036"></A><H4><A NAME="REF27292">8.2.2.   Initial Stack</A></H4>
<A NAME="U327037">Client programs <I>shall</I> be invoked with a valid stack pointer (<B>r</B><B>1</B>) with at least 32K bytes of memory available for stack growth. The stack pointer <I>shall</I> be 16-byte aligned, reserving sufficient room for a linkage area (32 bytes above the address in r1). If the system is executing in Real-Mode, the value in r1 is a real address; if in Virtual-Mode, the address in r1 is a mapped virtual address.</A><p>
<A NAME="U326318"></A><A NAME="U327038"></A><H4><A NAME="REF31886">8.2.3.   Client Interface Handler Address</A></H4>
<A NAME="U327039">When client programs are invoked, <B>r</B><B>5</B> <I>shall</I> contain the address of the entry point of the <I>client interface handler</I>. If the system is executing in Real-Mode, the value in r5 is a real address; if in Virtual-Mode, the address in r5 is a mapped virtual address.</A><p>
<A NAME="U327040">Note:  this address points to the first instruction of the <I>client interface handler</I>, not to a procedure descriptor.</A><p>
<A NAME="U326319"></A><A NAME="U327041"></A><H4><A NAME="REF13831">8.2.4.   Client Program Arguments</A></H4>
<A NAME="U327042">The calling program <I>may </I>pass to the client an array of bytes of arbitrary content; if this array is present, its address and length <I>shall</I> be passed in registers <B>r</B><B>6</B> and <B>r</B><B>7</B>, respectively. For programs booted directly by Open Firmware, the length of this array is zero. Secondary boot programs may use this argument array to pass information to the programs that they boot.</A><p>
<A NAME="U327043">Note:  The Open Firmware standard makes no provision for specifying such an array or its contents. Therefore, in the absence of implementation-dependent extensions, a client program executed directly from an Open Firmware implementation will not be passed such an array. However, intermediate boot programs that simulate or propagate the Open Firmware client interface to the programs that they load can provide such an array for their clients.</A><p>
<A NAME="U327044">Note:  boot command line arguments, typically consisting of the name of a file to be loaded by a secondary boot program followed by flags selecting various secondary boot and operating system options, are provided to client programs via the "bootargs" and "bootpath" properties of the "/chosen" node.</A><p>
<A NAME="U327048"></A><H3><A NAME="HDR28">8.3.   Caching</A></H3>
<A NAME="U327049">The caches of the processor <I>shall</I> be enabled when the client program is called. The I-cache shall be consistent with the D-cache for all memory areas occupied by the client program. Memory areas allocated on behalf of the client program <I>shall</I> be marked as cacheable. Accesses to "I/O" devices (especially, to devices across "bridges") <I>shall</I> be made with the register access words (e.g., <B>%r</B><B>l@</B>).  All processors in a SMP system shall have the same consistent view of all memory areas (for data references).  No more than one processor shall have a modified copy of the same data area in its cache when the client program is called.</A><p>
<A NAME="U334614">Note:  If firmware makes cachable M=0 data references from different processors on a SMP system, it may have to perform additional cache management to meet this requirement.</A><p>
<A NAME="U326320"></A><A NAME="U327050"></A><H3><A NAME="REF27751">8.4.   Interrupts</A></H3>
<A NAME="U327051">Open Firmware requires that interrupts be "vectored" to its handlers when it is in control of the processor; this will occur when the User Interface is running. Client Interface calls are considered to execute in the environment of the client, and hence, Open Firmware does not assume ownership of interrupts.</A><p>
<A NAME="U327052">In order for Open Firmware to process interrupts in an efficient manner, an area of memory for the exclusive use by Open Firmware <I>shall</I> be reserved by the client program at (real) memory locations 0x1E0...0x1FF.</A><p>
<A NAME="U327053">Open Firmware <I>shall</I> save and restore the first location of each interrupt that it wants to "take over". I.e., whenever Open Firmware needs the use of an interrupt, it <I>shall</I> save the current contents of the corresponding entry point and replace that location with a branch to its entry point. When Open Firmware returns control, it <I>shall</I> restore the RAM location to its original contents.</A><p>
<A NAME="U327054"></A><H3><A NAME="HDR29">8.5.   Client callbacks</A></H3>
<A NAME="U327055">This section defines the callback mechanism that allows Open Firmware to access services exported to it by the client program. As described in section 6.3.2 and the glossary entries for callback and $callback in <A HREF="ppc-1_10d.html#REF69242">[1]</A>, the callback mechanism follows the same rules as those of Client interface calls. I.e., an <I>argument array</I> is constructed by Open Firmware and the address of that array is passed (via <B>r</B><B>3</B>) to the client's callback routine; the address of the callback routine is supplied to Open Firmware by means of the set-callback client call.</A><p>
<A NAME="U327056">If the system is running in Real-Mode, the address of the client callback routine <I>shall</I> be a real address; if it is running in Virtual-Mode, the client callback routine address <I>shall</I> be a mapped virtual address.</A><p>
<A NAME="U326353"></A><A NAME="U327295"></A><H4><A NAME="REF11616">8.5.1.   Real-Mode physical memory management assist callback</A></H4>
<A NAME="U327298">Once the control of physical memory is transferred to the client program, Open Firmware which is running in real-mode <I>shall</I> use the callback service provided by the client program to allocate physical memory. Client programs which expect Open Firmware to operate in read-mode must implement the following physical memory management client callback routines for Open Firmware:</A><p>
<A NAME="U327297">alloc-real-mem</A><p>

<DL>
<A NAME="U327299"><DD>IN:  [address] min_addr, [address] max_addr, size, mode</A><BR>

<A NAME="U327300"><DD>OUT:    error,  [address] real_addr</A><BR>

<A NAME="U327301"><DD>This routine allocates a contiguous physical memory of <I>size</I> bytes within the address range between <I>min_addr </I>and<I> max_addr</I>. The <I>mode</I> parameter contains the WIMGxPP bits as defined in <A HREF="ppc-1_10d.html#REF77797">section 6.</A> A non-zero error code <I>shall</I> be returned if the mapping can not be performed. If error code is zero (i.e. allocation is succeeded) the routine returns the base address of the physical memory allocated for Open Firmware.</A><BR>
<A NAME="U326321"></A></DL>


<A NAME="U327057"></A><H4><A NAME="REF11616">8.5.2.   Virtual address translation assist callbacks</A></H4>
<A NAME="U327058">As mentioned in <A HREF="ppc-1_10d.html#REF96317">section 4.2.6.</A>, when Open Firmware is in Virtual-Mode, client programs that take over control of the system's memory management must provide a set of callbacks that implement MMU functions. This section defines the input arguments and return values for these callbacks. The notation follows the style used in chapter 6 of the Open Firmware specification <A HREF="ppc-1_10d.html#REF69242">[1]</A>.</A><p>
<A NAME="U327059">map</A><p>

<DL>
<A NAME="U327060"><DD>IN:  [address] phys, [address] virt, size, mode</A><BR>

<A NAME="U327061"><DD>OUT:  throw-code,   error</A><BR>

<A NAME="U327062"><DD>This routine creates system-specific translation information; this will typically include the addition of PTEs to the HTAB. If the mapping is successfully performed, a value of zero <I>shall</I> be placed in the <I>error</I> cell of the argument array; a non-zero error code <I>shall</I> be returned in <I>error</I> if the mapping can not be performed.</A><BR>
</DL>


<A NAME="U327063">unmap</A><p>

<DL>
<A NAME="U327064"><DD>IN:  [address] virt, size</A><BR>

<A NAME="U327065"><DD>OUT:  throw-code</A><BR>

<A NAME="U327066"><DD>The system removes any data structures (e.g., PTEs) for the virtual address range.</A><BR>
</DL>


<A NAME="U327067">translate</A><p>

<DL>
<A NAME="U327068"><DD>IN: [address] virt</A><BR>

<A NAME="U327069"><DD>OUT: throw-code, error, [address] real, mode</A><BR>

<A NAME="U327070"><DD>The system attempts to compute the real address (<I>real</I>) to which the virtual address (<I>virt</I>) is mapped. If the translation is successful, a PTE <I>shall</I> be placed into the HTAB for this translation, the number of return cells shall be four with the resulting real address returned in <I>real</I> and <I>error</I> shall be set to <B>false</B> (0). If the translation is not successful, the number of return cells <I>shall </I>be two and <I>error shall</I> be set to a non-zero error code.</A><BR>

<A NAME="U327071"><DD>This call <I>shall</I> be made when Open Firmware handles a DSI/ISI within the User interface. A successful result of the translate call indicates that Open Firmware can complete the interrupted access; a failure indicates that an access was made to an invalid address.</A><BR>
</DL>


<A NAME="U327072"></A><H2><A NAME="HDR30">9.   User Interface Requirements</A></H2>
<A NAME="U327073">An implementation of Open Firmware for PowerPC <I>shall</I> conform to the core requirements as specified in <A HREF="ppc-1_10d.html#REF69242">[1]</A> and the following PowerPC-specific extensions.</A><p>
<A NAME="U327074"></A><H3><A NAME="HDR31">9.1.   Machine Register Access</A></H3>
<A NAME="U327075">The following <I>user interface</I> commands represent PowerPC registers within the <I>saved program state</I>. Executing the command returns the saved value of the corresponding register. The saved value may be set by preceding the command with <B>to</B>; the actual registers are restored to the saved values when <B>go</B> is executed.</A><p>
<A NAME="U334625">The following command displays the PowerPC CPU's <I>saved program state</I>.</A><p>
<A NAME="U334626">.registers</A><p>
<A NAME="U327076"></A><H4><A NAME="HDR32">9.1.1.   Branch Unit Registers</A></H4>
<H4><A NAME="U327077">%cr</A></H4>
<A NAME="U327078">  Access saved copy of Condition Register.</A><p>
<H4><A NAME="U327079">%ctr</A></H4>
<A NAME="U327080">  Access saved copy of Count Register.</A><p>
<H4><A NAME="U327081">%lr</A></H4>
<A NAME="U327082">  Access saved copy of Link Register.</A><p>
<H4><A NAME="U327083">%msr</A></H4>
<A NAME="U327084">  Access saved copy of the low order 16 bits of SRR1 register.</A><p>
<H4><A NAME="U327085">%srr0 and %srr1</A></H4>
<A NAME="U327086">  Access saved copy of Save/Restore Registers.</A><p>
<H4><A NAME="U328169">%pc</A></H4>
<A NAME="U328173">An alias of "<B>%srr0</B>"</A><p>
<A NAME="U328166"></A><H4><A NAME="HDR33">9.1.2.   Fixed-Point Registers</A></H4>
<H4><A NAME="U327088">%r0 through %r31</A></H4>
<A NAME="U327089">  Access saved copies of fixed-point registers.</A><p>
<H4><A NAME="U327090">%xer</A></H4>
<A NAME="U327091">  Access saved copy of XER register.</A><p>
<H4><A NAME="U327092">%sprg0 through %sprg3</A></H4>
<A NAME="U327093">Access saved copies of SPRG registers.</A><p>
<A NAME="U327094"></A><H4><A NAME="HDR34">9.1.3.   Floating-Point Registers</A></H4>
<A NAME="U327095">Unlike the other registers, the floating point unit registers are not normally saved, since they are not used by Open Firmware. The following access words, therefore, access the registers directly.</A><p>
<H4><A NAME="U327096">%f0 through %f31</A></H4>
<A NAME="U327097">  Access floating point registers.</A><p>
<H4><A NAME="U327098">%fpscr</A></H4>
<A NAME="U327099">  Access Floating Point Status and Control Register.</A><p>
<A NAME="U327102"></A><H2><A NAME="HDR35">10.   Configuration Variables</A></H2>
<A NAME="U327103">In addition to the standard Configuration Variables defined by the core Open Firmware document <A HREF="ppc-1_10d.html#REF69242">[1]</A>, the following Configuration Variables <I>shall</I> be implemented for PowerPC:</A><p>
<H4><A NAME="U327104">"little-endian?"</A></H4>
<A NAME="U327105">This boolean variable controls the endian-mode of Open Firmware. If <B>true</B> (-1), the endian-mode is Little-Endian; if <B>false</B> (0), the endian-mode is Big-Endian. The default value is implementation dependent.</A><p>
<H4><A NAME="U327106">"real-mode?"</A></H4>
<A NAME="U327107">This boolean variable controls the address translation mode of Open Firmware. If true (-1), the addressing mode is Real-Mode; if false (0), the addressing mode is Virtual-Mode. The default value is implementation dependent.</A><p>
<H4><A NAME="U327108">"real-base"</A></H4>
<A NAME="U327109">This integer variable defines the starting physical address to be used by Open Firmware. </A><p>
<H4><A NAME="U327110">"real-size"</A></H4>
<A NAME="U328134">  This integer variable defines the size of the physical address space which can be used by Open Firmware. </A><p>
<H4><A NAME="U328141">"virt-base"</A></H4>
<A NAME="U328142">This integer variable defines the starting virtual memory address which can be used by Open Firmware. </A><p>
<H4><A NAME="U328143">"virt-size"</A></H4>
<H4><A NAME="U328135">  This integer variable defines the size of the virtual address space which can be used by Open Firmware.</A></H4>
<H4><A NAME="U328148"> "load-base"</A></H4>
<A NAME="U328506">This integer variable defines the default load address for <I>client program</I>s when using the <B>load</B> method. The default value is implementation dependent.</A><p>
<A NAME="U330198"></A><H2><A NAME="HDR36">11.   MP Extensions</A></H2>
<A NAME="U330199">This section specifies the application of Open Firmware to PowerPC multiprocessor (MP) systems. An Open Firmware implementation for an MP PowerPC system shall implement the extensions described in this section as well as the requirements described in previous sections of this binding.</A><p>
<A NAME="U330200"></A><H3><A NAME="HDR37">11.1.   The Device Tree</A></H3>
<A NAME="U330793">This section defines an additional property under the "/chosen" Node for a MP extension. Refer to Section <A HREF="ppc-1_10d.html#REF37877">5.1.1.</A> for more details about the device tree structure for a MP Configuration.</A><p>
<A NAME="U330204"></A><H4><A NAME="HDR38">11.1.1.   Additional Properties</A></H4>
<A NAME="U330205">"/chosen" Node Properties</A><p>
<H4><A NAME="U330206">"cpu"</A></H4>
<A NAME="U330207">prop-name, identifies the running CPU.</A><p>
<A NAME="U330208">prop-encode-array: An integer, encoded as with <B>encode-int, </B>which contains the i-handle of the CPU node that is associated with the "running" CPU.</A><p>
<A NAME="U330209"></A><H3><A NAME="HDR39">11.2.   Initialization</A></H3>
<A NAME="U330210">Open Firmware shall select one processor, using an algorithm of its choice, to be the "master" processor, which performs the role of the single processor on a uniprocessor system, either booting the client or providing the user interface. Open Firmware shall place all the remaining processors into stopped state, a state in which the processor does not perform Open Firmware or client functions and does not interfere with the operation of the master processor. A processor in stopped state remains in that state unless and until an executing client starts it using the start-cpu client service defined below.</A><p>
<A NAME="U332686">Client programs shall use the Open firmware start-cpu client interface service to start all processors before it reclaims the Open Firmware memory</A><p>
<A NAME="U332687">On machines in which a machine check on one processor is broadcast to all processors, the processors which are either in the idle or stopped state shall not change their states due to a machine check on another processor: Open Firmware shall not depend on the contents of the low vector (IP=0) in the event of a machine check.</A><p>
<A NAME="U332688">The following State Diagram depicts the relationship of the <B>Running</B>, <B>Stopped</B> and <B>Idle States</B> to each other. The <I>Client Interface Service</I> Calls are shown as how to move between the states. </A><p>
<B><A NAME="U332235">FIGURE  1  State Diagram</A></B><p>
<img src="ppc-1_10d.figure.id.1.gif"><p>
<A NAME="U330242">Note:  Open Firmware's memory cannot be reclaimed by a client if a CPU is in the "stopped" or "idle" state. </A><p>
<A NAME="U333054"></A><H3><A NAME="HDR40">11.3.   Client Interface Services</A></H3>
<A NAME="U330243">The following client interface services are added for MP support on PowerPC systems. These interfaces make the client program responsible for any Inter-CPU communication needed for these interfaces. The rationale for this is to architecturally separate the Inter-CPU communication mechanism of the firmware from the client program and vice versa.</A><p>
<A NAME="U330247">start-cpu</A><p>

<DL>
<A NAME="U330248"><DD>IN:  nodeid, pc, arg</A><BR>

<A NAME="U330249"><DD>OUT:    none</A><BR>

<A NAME="U330250"><DD>This client interface service starts the CPU.  The <I>nodeid</I> is the phandle of a node whose device_type is "cpu". </A><BR>

<A NAME="U330252"><DD>Start-cpu arranges for the CPU identified by phandle in <I>nodeid</I> to begin executing client code at the real address given by the <I>pc </I>input with an argument, <I>arg,</I> passed in register r3. When it begins execution, the started processor shall be in the endian mode of the client program, and in real (not translated) addressing mode. The contents of registers other than r3 are indeterminate. </A><BR>

<A NAME="U330253"><DD> A client should not call start-cpu for the processor on which it is running, effectively restarting with a new pc and abandoning the only client thread. A jump or branch instruction shall be used instead to achieve the objective.</A><BR>

<A NAME="U330254"><DD>start-cpu permits more than one processor to run at the same time, enabling multi-threaded client execution. In general, an Open Firmware client shall avoid multi-threaded operation within Open Firmware. Usually, this means that client threads running on different CPUs must use mutual exclusion to prevent more than one processor from making client service requests at any one time. The exceptions are that a client thread may invoke either the STOP-SELF or IDLE-SELF client services defined below at any time.</A><BR>
</DL>


<A NAME="U330255">Note:  The results are undefined if the CPU identified by *phandle* has already been started (e.g it is already running and has not exited) or *phandle* is not a valid package handle of a CPU device node.</A><p>
<A NAME="U330257">stop-self</A><p>

<DL>
<A NAME="U330258"><DD>IN:  none</A><BR>

<A NAME="U330259"><DD>OUT:    none</A><BR>

<A NAME="U330260"><DD>Open Firmware places the processor on which the caller was running into the "stopped" state. The client program is not-resumable.</A><BR>
</DL>


<A NAME="U330262">Note:  When an MP client program exits, one CPU invokes the EXIT client interface service, the others invoke the STOP-SELF service.</A><p>
<A NAME="U330264">idle-self</A><p>

<DL>
<A NAME="U330265"><DD>IN:  none</A><BR>

<A NAME="U330266"><DD>OUT:    none</A><BR>

<A NAME="U332154"><DD>Open Firmware places the CPU on which this service was invoked into an 'idle' state, saving the *current state* of the client program, so that the client program may be resumed.</A><BR>

<A NAME="U332155"><DD>A processor in idle state can be resumed using RESUME-CPU service defined below or restarted using START-CPU. If the processor is resumed, it executes a normal return to the client, as if its call to IDLE-SELF had just completed.</A><BR>
</DL>


<A NAME="U330269">Note:  When a client program wants to enter the firmware user interface, one CPU invokes the ENTER client interface service, the others invoke the IDLE-SELF service. The rational is that the user interface may affect the machine state in any way that it desires, therefore the client shall not depend on it.</A><p>
<A NAME="U330271">resume-cpu</A><p>

<DL>
<A NAME="U330272"><DD>IN:  nodeid</A><BR>

<A NAME="U330273"><DD>OUT:    none</A><BR>

<A NAME="U330274"><DD>This client interface service is used to resume an *idled* CPU. The <I>nodeid</I> is the phandle of a CPU node in idle state.</A><BR>

<A NAME="U330276"><DD>RESUME-CPU arranges for that CPU to restore the CPU's state as saved by IDLE-SELF and begin return to the client, completing the idle-self client service call that placed the CPU into idle state. The results are undefined if the CPU identified by *phandle* is not in an *idle* state by a previous call to the IDLE-SELF client interface service.</A><BR>
</DL>


<A NAME="U330278">Note:  When the client program is resumed via the GO (or similar) user interface command, the client program is resumed on the CPU which called the ENTER service; the client program is responsible for calling the RESUME-CPU service to resume other idled CPU's, if that is the desired client program behavior.</A><p>
<A NAME="U330281"></A><H3><A NAME="HDR41">11.4.   Breakpoints</A></H3>
<A NAME="U330282">If the breakpoint is taken by the firmware, without the client program's assistance, the other CPUs will continue to run in the client program. The client program may field the breakpoint 'trap' or 'vector' and idle the other CPUs before entering the PROM. The platform binding document has to specify how this is done to avoid loss of state at breakpoint time.</A><p>
<A NAME="U330283"></A><H3><A NAME="HDR42">11.5.   Serialization</A></H3>
<A NAME="U330284">The firmware is a single threaded program, from the client program's point of view. Only the idle-self, stop-self, enter and exit client interfaces may be invoked simultaneously on different CPUs. Furthermore, only a single CPU may invoke the enter or exit client interface at any one time. The other CPUs must use the idle-self or stop-self client interface service.</A><p>
<A NAME="U330285">Note:   The results are undefined if the client program invokes client interface services including breakpoint traps (other than the enter/exit stop-self/idle-self case listed above) simultaneously on more than a single CPU.</A><p>
<A NAME="U330286">Note:  Since locking mechanisms are subject to client program policy, the client program is responsible for implementing any necessary mechanism to insure that it adheres to this policy. Further, the client program should disable any pre-emption mechanism before calling a client interface service to avoid rescheduling a thread of execution in the firmware on a different CPU if such a mechanism exists in the client program.</A><p>
<HR><h3>Footnotes</h3><DL COMPACT><DT><A NAME=FN1>(1)</A><DD>The 601 has a single set of BAT entries that are shared by both instruction and data accesses.</DL><A NAME="ENDFILE"><PRE> </PRE></A>
</HTML>
